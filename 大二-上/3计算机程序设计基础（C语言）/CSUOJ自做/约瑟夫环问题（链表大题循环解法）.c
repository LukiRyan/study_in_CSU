#include<stdio.h>//难以置信！我不用链表只用循环就一遍过了！！！

int main()
{
    int n,m;
    while(scanf("%d",&n)!=EOF)
    {
        scanf("%d",&m);
        int a[n+1];
        for(int i=1; i<=n; i++)
        {
            a[i]=i;
        }
        int j=0,q=n;
        while(1)
        {
            for(int i=0; i<m; )
            {
                j++;
                if(j == n+1)
                {
                    j=1;
                }
                if(a[j] != 0)
                {
                    i++;
                }
            }
            here:
            if(a[j] != 0)
            {
                printf("%d ",a[j]);
                a[j]=0;//原创老办法：因为编号不会为0，所以0可以充当标记
                q--;
                if(q == 0)
                    {
                        break;
                    }
                continue;
            }
            else//(a[j] == 0)
            {
                j++;
                goto here;
            }
        }
        printf("\n");
    }
    return 0;
}

/*
问题 A: 约瑟夫环问题
[命题人 : 211072]
时间限制 : 1.000 sec  内存限制 : 128 MB

题目描述
已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为1的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。
输入
多组样例。每个样例输入包括两行，第一行为n，第二行为m。
输出
对于每一组样例，输出n个人出环的顺序。
样例输入 Copy
10
6
8
3
9
7
样例输出 Copy
6 2 9 7 5 8 1 10 4 3
3 6 1 5 2 8 4 7
7 5 4 6 9 3 8 1 2
*/